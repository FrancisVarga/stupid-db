import { type TableInfo, type ColumnInfo, listTables, listSchemas, getColumns } from "./introspect";
import { udtToJsonSchema, type JsonSchemaType } from "./serialize";
import type postgres from "postgres";

// ── Types ──────────────────────────────────────────────────────────

interface OpenAPISpec {
  openapi: string;
  info: { title: string; version: string; description: string };
  servers: Array<{ url: string }>;
  paths: Record<string, Record<string, unknown>>;
  components: { schemas: Record<string, unknown> };
}

// ── Generator ──────────────────────────────────────────────────────

/**
 * Auto-generate an OpenAPI 3.1 spec from introspected database schema.
 */
export async function generateOpenAPISpec(
  sql: postgres.Sql,
  dbName: string,
  baseUrl: string,
): Promise<OpenAPISpec> {
  const dbSchemas = await listSchemas(sql);
  const schemas: Record<string, unknown> = {};
  const paths: Record<string, Record<string, unknown>> = {};

  for (const dbSchema of dbSchemas) {
    const tables = await listTables(sql, dbSchema);

    for (const table of tables) {
      if (table.name === "_stupid_audit") continue; // Skip internal table

      const columns = await getColumns(sql, table.name, dbSchema);
      const { schemaObj, requiredFields, pkFields } = buildTableSchema(table, columns);

      // Namespace component names by schema to avoid collisions
      const prefix = dbSchema === "public" ? "" : pascalCase(dbSchema);
      const schemaName = `${prefix}${pascalCase(table.name)}`;
      const inputSchemaName = `${schemaName}Input`;
      const tag = dbSchema === "public" ? table.name : `${dbSchema}.${table.name}`;

      // Full schema (response)
      schemas[schemaName] = schemaObj;

      // Input schema (request — exclude auto-generated columns)
      const inputProperties: Record<string, unknown> = {};
      const inputRequired: string[] = [];
      for (const col of columns) {
        if (isAutoGenerated(col)) continue;
        inputProperties[col.name] = columnToJsonSchema(col);
        if (!col.nullable && !col.column_default) {
          inputRequired.push(col.name);
        }
      }
      schemas[inputSchemaName] = {
        type: "object",
        properties: inputProperties,
        ...(inputRequired.length > 0 ? { required: inputRequired } : {}),
      };

      // Schema query param suffix for non-public schemas
      const schemaSuffix = dbSchema !== "public" ? `?schema=${encodeURIComponent(dbSchema)}` : "";

      // ── List + Create path: /api/v1/{db}/{table}
      const listPath = `/api/v1/${dbName}/${table.name}${schemaSuffix}`;
      paths[listPath] = {
        get: buildListOp(table, schemaName, tag, dbSchema),
        post: buildCreateOp(table, inputSchemaName, tag, dbSchema),
        patch: buildBatchUpdateOp(table, inputSchemaName, tag, dbSchema),
        delete: buildBatchDeleteOp(table, tag, dbSchema),
      };

      // ── Single record path: /api/v1/{db}/{table}/{id}
      if (pkFields.length > 0) {
        const singlePath = `/api/v1/${dbName}/${table.name}/{id}${schemaSuffix}`;
        paths[singlePath] = {
          get: buildGetOp(table, schemaName, tag, dbSchema),
          put: buildUpdateOp(table, inputSchemaName, tag, dbSchema),
          delete: buildDeleteOp(table, tag, dbSchema),
        };
      }
    }
  }

  // ── Query path
  paths[`/api/v1/${dbName}/query`] = {
    post: {
      summary: "Execute raw SQL query",
      operationId: `query_${dbName}`,
      tags: ["Query"],
      requestBody: {
        required: true,
        content: {
          "application/json": {
            schema: {
              type: "object",
              properties: {
                sql: { type: "string", description: "SQL query to execute" },
                params: { type: "array", items: {}, description: "Query parameters" },
              },
              required: ["sql"],
            },
          },
        },
      },
      responses: {
        "200": {
          description: "Query results",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  columns: { type: "array", items: { type: "string" } },
                  rows: { type: "array", items: { type: "object" } },
                  rowCount: { type: "integer" },
                  duration_ms: { type: "number" },
                },
              },
            },
          },
        },
      },
    },
  };

  return {
    openapi: "3.1.0",
    info: {
      title: `stupid-db: ${dbName}`,
      version: "1.0.0",
      description: `Auto-generated API for PostgreSQL database "${dbName}". Supports full CRUD, filtering, pagination, sorting, search, batch operations, and raw SQL queries.`,
    },
    servers: [{ url: baseUrl }],
    paths,
    components: { schemas },
  };
}

// ── Helpers ────────────────────────────────────────────────────────

function pascalCase(s: string): string {
  return s
    .split(/[_\s-]+/)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join("");
}

function isAutoGenerated(col: ColumnInfo): boolean {
  if (!col.column_default) return false;
  const d = col.column_default.toLowerCase();
  return d.includes("nextval(") || d.includes("gen_random_uuid()") || d === "now()";
}

function columnToJsonSchema(col: ColumnInfo): JsonSchemaType {
  const schema = udtToJsonSchema(col.udt_name);
  if (col.nullable) {
    return { ...schema, description: (schema.description ? schema.description + " | " : "") + "nullable" };
  }
  return schema;
}

function buildTableSchema(
  _table: TableInfo,
  columns: ColumnInfo[],
): { schemaObj: Record<string, unknown>; requiredFields: string[]; pkFields: string[] } {
  const properties: Record<string, unknown> = {};
  const requiredFields: string[] = [];
  const pkFields: string[] = [];

  for (const col of columns) {
    properties[col.name] = columnToJsonSchema(col);
    if (!col.nullable && !col.column_default) {
      requiredFields.push(col.name);
    }
    if (col.is_pk) {
      pkFields.push(col.name);
    }
  }

  return {
    schemaObj: {
      type: "object",
      properties,
      ...(requiredFields.length > 0 ? { required: requiredFields } : {}),
    },
    requiredFields,
    pkFields,
  };
}

function paginationParams(): unknown[] {
  return [
    { name: "page", in: "query", schema: { type: "integer", default: 1 }, description: "Page number" },
    { name: "limit", in: "query", schema: { type: "integer", default: 50, maximum: 1000 }, description: "Items per page" },
    { name: "sort", in: "query", schema: { type: "string" }, description: "Column to sort by" },
    { name: "order", in: "query", schema: { type: "string", enum: ["asc", "desc"], default: "desc" }, description: "Sort order" },
    { name: "filter", in: "query", schema: { type: "string" }, description: "JSON filter object. Operators: __gte, __lte, __gt, __lt, __ne, __like, __ilike, __in, __is_null" },
    { name: "search", in: "query", schema: { type: "string" }, description: "Search keyword (ILIKE)" },
    { name: "search_cols", in: "query", schema: { type: "string" }, description: "Comma-separated columns to search in" },
    { name: "select", in: "query", schema: { type: "string" }, description: "Comma-separated columns to return" },
  ];
}

function schemaParam(dbSchema: string): unknown[] {
  if (dbSchema === "public") return [];
  return [
    { name: "schema", in: "query", required: true, schema: { type: "string", default: dbSchema }, description: "Database schema name" },
  ];
}

function buildListOp(table: TableInfo, schemaName: string, tag: string, dbSchema: string): Record<string, unknown> {
  return {
    summary: `List ${tag} records`,
    operationId: `list_${dbSchema === "public" ? "" : dbSchema + "_"}${table.name}`,
    tags: [tag],
    parameters: [...paginationParams(), ...schemaParam(dbSchema)],
    responses: {
      "200": {
        description: "Paginated list of records",
        content: {
          "application/json": {
            schema: {
              type: "object",
              properties: {
                data: { type: "array", items: { $ref: `#/components/schemas/${schemaName}` } },
                total: { type: "integer" },
                page: { type: "integer" },
                limit: { type: "integer" },
                total_pages: { type: "integer" },
              },
            },
          },
        },
      },
    },
  };
}

function buildCreateOp(table: TableInfo, inputSchemaName: string, tag: string, dbSchema: string): Record<string, unknown> {
  return {
    summary: `Create ${tag} record(s)`,
    operationId: `create_${dbSchema === "public" ? "" : dbSchema + "_"}${table.name}`,
    tags: [tag],
    parameters: [...schemaParam(dbSchema)],
    requestBody: {
      required: true,
      content: {
        "application/json": {
          schema: {
            oneOf: [
              { $ref: `#/components/schemas/${inputSchemaName}` },
              { type: "array", items: { $ref: `#/components/schemas/${inputSchemaName}` } },
            ],
          },
        },
      },
    },
    responses: {
      "201": {
        description: "Created record(s)",
        content: {
          "application/json": {
            schema: {
              type: "object",
              properties: {
                data: { type: "array", items: { $ref: `#/components/schemas/${pascalCase(table.name)}` } },
                count: { type: "integer" },
              },
            },
          },
        },
      },
    },
  };
}

function buildBatchUpdateOp(table: TableInfo, inputSchemaName: string, tag: string, dbSchema: string): Record<string, unknown> {
  return {
    summary: `Batch update ${tag} records`,
    operationId: `batch_update_${dbSchema === "public" ? "" : dbSchema + "_"}${table.name}`,
    tags: [tag],
    parameters: [...schemaParam(dbSchema)],
    requestBody: {
      required: true,
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties: {
              ids: { type: "array", items: { type: "string" }, description: "Primary key values to update" },
              updates: { $ref: `#/components/schemas/${inputSchemaName}` },
            },
            required: ["ids", "updates"],
          },
        },
      },
    },
    responses: {
      "200": { description: "Updated records", content: { "application/json": { schema: { type: "object" } } } },
    },
  };
}

function buildBatchDeleteOp(table: TableInfo, tag: string, dbSchema: string): Record<string, unknown> {
  return {
    summary: `Batch delete ${tag} records`,
    operationId: `batch_delete_${dbSchema === "public" ? "" : dbSchema + "_"}${table.name}`,
    tags: [tag],
    parameters: [...schemaParam(dbSchema)],
    requestBody: {
      required: true,
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties: {
              ids: { type: "array", items: { type: "string" }, description: "Primary key values to delete" },
            },
            required: ["ids"],
          },
        },
      },
    },
    responses: {
      "200": { description: "Deleted records", content: { "application/json": { schema: { type: "object" } } } },
    },
  };
}

function buildGetOp(table: TableInfo, schemaName: string, tag: string, dbSchema: string): Record<string, unknown> {
  return {
    summary: `Get single ${tag} record`,
    operationId: `get_${dbSchema === "public" ? "" : dbSchema + "_"}${table.name}`,
    tags: [tag],
    parameters: [
      { name: "id", in: "path", required: true, schema: { type: "string" }, description: "Primary key value (composite: val1--val2)" },
      ...schemaParam(dbSchema),
    ],
    responses: {
      "200": {
        description: "Single record",
        content: { "application/json": { schema: { $ref: `#/components/schemas/${schemaName}` } } },
      },
      "404": { description: "Record not found" },
    },
  };
}

function buildUpdateOp(table: TableInfo, inputSchemaName: string, tag: string, dbSchema: string): Record<string, unknown> {
  return {
    summary: `Update single ${tag} record`,
    operationId: `update_${dbSchema === "public" ? "" : dbSchema + "_"}${table.name}`,
    tags: [tag],
    parameters: [
      { name: "id", in: "path", required: true, schema: { type: "string" }, description: "Primary key value" },
      ...schemaParam(dbSchema),
    ],
    requestBody: {
      required: true,
      content: {
        "application/json": { schema: { $ref: `#/components/schemas/${inputSchemaName}` } },
      },
    },
    responses: {
      "200": { description: "Updated record", content: { "application/json": { schema: { type: "object" } } } },
    },
  };
}

function buildDeleteOp(table: TableInfo, tag: string, dbSchema: string): Record<string, unknown> {
  return {
    summary: `Delete single ${tag} record`,
    operationId: `delete_${dbSchema === "public" ? "" : dbSchema + "_"}${table.name}`,
    tags: [tag],
    parameters: [
      { name: "id", in: "path", required: true, schema: { type: "string" }, description: "Primary key value" },
      ...schemaParam(dbSchema),
    ],
    responses: {
      "200": { description: "Deleted record" },
      "404": { description: "Record not found" },
    },
  };
}
