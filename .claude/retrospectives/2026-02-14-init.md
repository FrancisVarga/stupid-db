# Retrospective: 2026-02-14 — Init Session

## Session Focus
Brainstorm and document stupid-db — a unified knowledge materialization engine combining document, vector, and graph databases in Rust with a Next.js + D3.js chat-first dashboard.

## Learnings by Category

### Mistakes (M)
- Proposed generic architecture before examining actual sample data — the entity model only became clear after reading parquet schemas
- Assumed one-time graph construction; user clarified continuous streaming with rolling window was required

### Good Decisions (G)
- Iterative clarification (propose → clarify → revise) led to better final architecture
- Data-driven entity discovery from sample parquet files grounded the graph schema in reality
- Chat-first interface aligned naturally with LLM query plan architecture
- Structured 39-file documentation organized by logical subsystem

### Patterns (P)
- Progressive data understanding: abstract requirements → generic design → data discovery → revised design grounded in reality
- Scale numbers (960K events/day, 3-5TB) eliminate entire architecture families early
- Requirement clarification through multiple iteration rounds extracts specifics from vague vision

### Debugging (D)
- Parquet schema inspection (read schema + sample rows) reveals domain model for unknown data sources

### Architecture (A)
- Streaming materialization (Kappa) over batch ETL — driven by rolling window + continuous auto-connect
- Separate storage/compute/query layers for independent scaling
- Entity-centric graph schema: stable entities → nodes, events → edges with timestamps
- Pluggable embedder trait for multi-provider support (ONNX/Ollama/OpenAI)
- Dashboard as exploration UI (ad-hoc NL queries) not monitoring UI (fixed charts)

## Changes Applied

### Rules
- Created CLAUDE.md with 4 rules (data safety, design workflow)
- Created .claude/rules/rust.md with 4 rules (LLM providers, entity model, segments, workspace)
- Created .claude/rules/nextjs.md with 3 rules (chat-first, D3.js, no auth)

### Knowledge Graph
- Iterative design pattern (propose → clarify → revise)
- Data-driven entity discovery technique
- Parquet schema inspection technique
- Streaming materialization architecture decision
- Separated storage/compute/query layers
- Exploration UI vs monitoring UI distinction
- Entity-centric graph schema from event data pattern

## Notes
- This was a pure brainstorming + documentation session — no code written yet
- Architecture evolved significantly: static unified DB → streaming knowledge materialization engine
- Sample data at D:\w88_data (104GB, ~960K events/day) was the key pivot point for entity model design
