# ─── eisenbahn.toml ─────────────────────────────────────────────────
# Configuration for the eisenbahn messaging layer (PUB/SUB + PUSH/PULL).
#
# Environment variable overrides:
#   EISENBAHN_BROKER_FRONTEND     → broker.frontend
#   EISENBAHN_BROKER_BACKEND      → broker.backend
#   EISENBAHN_BROKER_METRICS_PORT → broker.metrics_port
#   EISENBAHN_TRANSPORT_KIND      → transport.kind
#   EISENBAHN_TRANSPORT_DEFAULT_HOST → transport.default_host
#   EISENBAHN_TRANSPORT_BASE_PORT → transport.base_port

# ─── Broker ─────────────────────────────────────────────────────────
# The central PUB/SUB message hub. Publishers connect to `frontend`,
# subscribers connect to `backend`. The broker proxies between them.

[broker]
frontend = "ipc:///tmp/stupid-db/broker-frontend.sock"
backend  = "ipc:///tmp/stupid-db/broker-backend.sock"
metrics_port = 9090

# ─── Transport defaults ─────────────────────────────────────────────
# Controls auto-assigned endpoints for workers and pipeline stages.
#   kind = "ipc"  → Unix domain sockets (single-host, fastest)
#   kind = "tcp"  → TCP sockets (distributed deployment)

[transport]
kind         = "ipc"
default_host = "127.0.0.1"
base_port    = 5560

# ─── Workers ────────────────────────────────────────────────────────
# Named worker processes that subscribe to broker events and/or
# connect to pipeline stages. Each can be scaled horizontally.

[workers.ingest]
binary        = "ingest-worker"
subscriptions = ["raw.parquet", "raw.csv"]
pipelines     = ["ingest"]
instances     = 2

[workers.ingest.env]
RUST_LOG = "info"

[workers.compute]
binary        = "compute-worker"
subscriptions = ["entity.created", "entity.updated"]
pipelines     = ["compute"]
instances     = 1

[workers.graph]
binary        = "graph-worker"
subscriptions = ["edge.derived"]
pipelines     = ["graph"]
instances     = 1

[workers.llm]
binary        = "llm-worker"
subscriptions = ["eisenbahn.compute.complete"]
pipelines     = []
instances     = 1

[workers.agent]
binary        = "agent-worker"
subscriptions = ["eisenbahn.compute.complete"]
pipelines     = []
instances     = 1

[workers.athena]
binary        = "athena-worker"
subscriptions = ["eisenbahn.ingest.complete"]
pipelines     = []
instances     = 1

[workers.catalog]
binary        = "catalog-worker"
subscriptions = ["eisenbahn.rule.changed"]
pipelines     = []
instances     = 1

# ─── Pipeline stages ────────────────────────────────────────────────
# DAG of processing stages connected by PUSH/PULL sockets.
# `after` defines upstream dependencies (must complete before this stage).
# `concurrency` sets the number of parallel PULL workers per stage.

[pipeline.stages.ingest]
concurrency = 4
# Entry point — no `after` dependencies

[pipeline.stages.compute]
after       = ["ingest"]
concurrency = 2

[pipeline.stages.graph]
after       = ["compute"]
concurrency = 1
# endpoint = "tcp://10.0.0.1:5570"  # Override for remote graph worker

# ─── Services (DEALER/ROUTER request/reply) ────────────────────────
# Named service endpoints for request/reply routing.
# The server connects DEALER sockets here; workers bind ROUTER sockets.

[services.query]
endpoint     = "ipc:///tmp/stupid-db/svc-query.sock"
timeout_secs = 30

[services.agent]
endpoint     = "ipc:///tmp/stupid-db/svc-agent.sock"
timeout_secs = 60

[services.athena]
endpoint     = "ipc:///tmp/stupid-db/svc-athena.sock"
timeout_secs = 120

[services.catalog]
endpoint     = "ipc:///tmp/stupid-db/svc-catalog.sock"
timeout_secs = 30
